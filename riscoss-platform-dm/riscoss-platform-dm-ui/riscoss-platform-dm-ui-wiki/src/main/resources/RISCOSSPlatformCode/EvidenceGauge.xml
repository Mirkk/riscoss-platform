<?xml version='1.0' encoding='UTF-8'?>
<xwikidoc version="1.1">
  <web>RISCOSSPlatformCode</web>
  <name>EvidenceGauge</name>
  <language/>
  <defaultLanguage>en</defaultLanguage>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <creationDate>1412870338000</creationDate>
  <parent>RISCOSSPlatformCode.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <date>1412870523000</date>
  <contentUpdateDate>1412870441000</contentUpdateDate>
  <version>3.1</version>
  <title>EvidenceGauge</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>false</hidden>
  <content>{{groovy}}&#xd;
&#xd;
import java.awt.Color;&#xd;
import java.awt.Graphics2D;&#xd;
import java.awt.LinearGradientPaint;&#xd;
import java.awt.Paint;&#xd;
import java.awt.RadialGradientPaint;&#xd;
import java.awt.RenderingHints;&#xd;
import java.awt.geom.Arc2D;&#xd;
import java.awt.geom.Point2D;&#xd;
import java.awt.image.BufferedImage;&#xd;
&#xd;
import eu.riscoss.reasoner.Evidence;&#xd;
&#xd;
public class EvidenceGauge extends BufferedImage {&#xd;
	&#xd;
	public EvidenceGauge( Evidence e, int w, int h ) {&#xd;
		super( w, h, BufferedImage.TYPE_INT_ARGB );&#xd;
		&#xd;
		Graphics2D g = (Graphics2D)getGraphics();&#xd;
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );&#xd;
		g.setColor( Color.white );&#xd;
		g.fillRect( 0, 0, w, h );&#xd;
		paint( e, g, 5, 5, w -10, h -10 );&#xd;
	}&#xd;
	&#xd;
	private void paint( Evidence e, Graphics2D g, int x, int y, int w, int h ) {&#xd;
		&#xd;
		g.setColor( Color.black );&#xd;
		&#xd;
		Point2D origin = pt( x + (w /2), y + h );&#xd;
		&#xd;
		double xofs = ((w) /2) /4;&#xd;
		&#xd;
		Paint paint = new LinearGradientPaint( &#xd;
				new Point2D.Double( x, y + h / 2 ),&#xd;
				new Point2D.Double( x + w, y + h / 2 ),&#xd;
				(float[]) [ 0.1f, 0.9f ],&#xd;
				(Color[]) [ Color.red, Color.green ] );&#xd;
		g.setPaint(paint);&#xd;
		g.fill( mkArc( origin, &#xd;
				rotate( pt( x, y + h ), &#xd;
						origin, (90 * (1 - e.getNegative())) ), &#xd;
				rotate( pt( x + w, y + h ), &#xd;
						origin, -(90 - (90 * e.getPositive())) ), Arc2D.PIE ) );&#xd;
		&#xd;
		g.setPaint( null );&#xd;
		&#xd;
		// Draw surrounding bars&#xd;
//		g.setColor( Color.black );&#xd;
//		g.draw( mkArc( origin, &#xd;
//				rotate( pt( x + w, y + h ), origin, -(90 -((90 * (e.getDirection() + (e.getConflict() /2)))) ) ), &#xd;
//				rotate( pt( x + w, y + h ), origin, -(90 -((90 * (e.getDirection() - (e.getConflict() /2)))) ) ), &#xd;
//				Arc2D.PIE ) );&#xd;
		&#xd;
		g.setColor( Color.black );&#xd;
		for( int i = 0; i &lt; 4; i++ ) {&#xd;
			g.draw( mkArc( origin, &#xd;
					pt( x + (xofs * i), y + h ), &#xd;
					pt( x + w - (xofs * i), y + h ), Arc2D.CHORD ) );&#xd;
		}&#xd;
		&#xd;
		Point2D r = rotate( &#xd;
						pt( x + ((w /2) + (e.getStrength() * (w /2))), y + h ), &#xd;
						origin, &#xd;
						-(90 -(90 * e.getDirection()) ) );&#xd;
		&#xd;
		Paint fuzziness = new RadialGradientPaint( &#xd;
				r, &#xd;
				(float)(180 * e.getConflict()) + 1f, &#xd;
				(float[]) [ 0.0f, 0.5f ], &#xd;
				(Color[]) [ Color.darkGray, new Color( 0, 0, 0, 0 ) ] );&#xd;
		&#xd;
		int sz = (int)(180 * e.getConflict());&#xd;
		g.setPaint( fuzziness );&#xd;
		g.setClip( mkArc( origin, &#xd;
				pt( x, y + h ), &#xd;
				pt( x + w, y + h ), Arc2D.CHORD ) );&#xd;
		g.fillOval( (int)r.getX() -(sz /2), (int)r.getY() -(sz /2), sz, sz );&#xd;
		&#xd;
		g.setColor( Color.white );&#xd;
		g.fillOval( (int)r.getX() -5, (int)r.getY() -5, 10, 10 );&#xd;
		g.setColor( Color.black );&#xd;
		g.drawOval( (int)r.getX() -5, (int)r.getY() -5, 10, 10 );&#xd;
		g.drawOval( (int)r.getX() -5, (int)r.getY() -5, 10, 10 );&#xd;
		g.drawLine( (int)r.getX(), (int)r.getY() -5, (int)r.getX(), (int)r.getY() +5 );&#xd;
		g.drawLine( (int)r.getX() -5, (int)r.getY(), (int)r.getX() +5, (int)r.getY() );&#xd;
	}&#xd;
	&#xd;
	Point2D pt( double x, double y ) {&#xd;
		return new Point2D.Double(x, y);&#xd;
	}&#xd;
	&#xd;
	public Point2D rotate(Point2D pt, Point2D center, double angleDeg)&#xd;
	{&#xd;
		double angleRad = (angleDeg/180)*Math.PI;&#xd;
		double cosAngle = Math.cos(angleRad );&#xd;
		double sinAngle = Math.sin(angleRad );&#xd;
		double dx = (pt.getX()-center.getX());&#xd;
		double dy = (pt.getY()-center.getY());&#xd;
		&#xd;
		return new Point2D.Double( &#xd;
				center.getX() + (int) (dx*cosAngle-dy*sinAngle),&#xd;
				center.getY() + (int) (dx*sinAngle+dy*cosAngle) );&#xd;
	}&#xd;
	&#xd;
	double dist0( Point2D origin, double x, double y) {&#xd;
		return Math.sqrt(sqr(x - origin.getX()) + sqr(y - origin.getY()));&#xd;
	}&#xd;
	&#xd;
	// Return polar angle of any point relative to arc center.&#xd;
	double angle0( Point2D origin, double x, double y ) {&#xd;
		return Math.toDegrees(Math.atan2( origin.getY() - y, x - origin.getX() ));&#xd;
	}&#xd;
	&#xd;
	static float sqr(float x) { return x * x; }&#xd;
	static double sqr(double x) { return x * x; }&#xd;
	&#xd;
	static double angleDiff(double a, double b) {&#xd;
		double d = b - a;&#xd;
		while (d >= 180f) { d -= 360f; }&#xd;
		while (d &lt; -180f) { d += 360f; }&#xd;
		return d;&#xd;
	}&#xd;
	&#xd;
	Arc2D mkArc( Point2D origin, Point2D left, Point2D right, int type ) {&#xd;
		&#xd;
		// Get radii of anchor and det point.&#xd;
		double ra = dist0( origin, left.getX(), left.getY());&#xd;
		double rd = dist0( origin, right.getX(), right.getY() );&#xd;
		&#xd;
		// If either is zero there's nothing else to draw.&#xd;
		if (ra == 0 || rd == 0) { return new Arc2D.Double(); }&#xd;
		&#xd;
		// Get the angles from center to points.&#xd;
		double aa = angle0( origin, left.getX(), left.getY() );&#xd;
		double ad = angle0( origin, right.getX(), right.getY() );&#xd;
		&#xd;
		// Draw the arc and other dots.&#xd;
		return new Arc2D.Double( &#xd;
				origin.getX() - ra, origin.getY() - ra, // box upper left&#xd;
				2 * ra, 2 * ra,                  // box width and height&#xd;
				aa, angleDiff(aa, ad),           // angle start, extent &#xd;
				type );&#xd;
	}&#xd;
}&#xd;
&#xd;
int width = 100;&#xd;
int height = 50;&#xd;
&#xd;
if(request.positive != null &amp;&amp; request.negative != null) {&#xd;
  if(request.width != null) {&#xd;
    width = Integer.parseInt(request.width);&#xd;
    height = width / 2;&#xd;
  }&#xd;
  &#xd;
  EvidenceGauge eg = new EvidenceGauge(new Evidence(Double.parseDouble(request.positive), Double.parseDouble(request.negative)), width, height);&#xd;
&#xd;
  response.setContentType("image/png");&#xd;
  javax.imageio.ImageIO.write(eg, "png", response.getOutputStream());&#xd;
  response.flush();&#xd;
}&#xd;
&#xd;
{{/groovy}}</content>
</xwikidoc>