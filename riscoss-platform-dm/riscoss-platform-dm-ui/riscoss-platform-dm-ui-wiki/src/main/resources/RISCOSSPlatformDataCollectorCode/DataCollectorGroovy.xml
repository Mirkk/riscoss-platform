<?xml version="1.0" encoding="UTF-8"?>
<xwikidoc>
  <web>RISCOSSPlatformDataCollectorCode</web>
  <name>DataCollectorGroovy</name>
  <language />
  <defaultLanguage />
  <translation>0</translation>
  <parent>xwiki:XWiki.WebHome</parent>
  <creator>xwiki:XWiki.Admin</creator>
  <author>xwiki:XWiki.Admin</author>
  <customClass />
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <creationDate>1357694025000</creationDate>
  <date>1357696926000</date>
  <contentUpdateDate>1357696926000</contentUpdateDate>
  <version>1.1</version>
  <title />
  <template />
  <defaultTemplate />
  <validationScript />
  <comment />
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>false</hidden>
  <content>/* -*- Mode:Java
 * Groovy code for data collectors.
 */
import org.json.JSONObject;
import org.json.JSONArray;
import java.util.ArrayList;
import java.util.HashMap;
import org.json.JSONObject;
import java.util.concurrent.atomic.AtomicInteger;
import org.apache.commons.io.IOUtils;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.client.HttpClient;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;

public class Ctx {

    static final int COLLECTOR_TIMEOUT_MILLISECONDS = 600000;

    final Object xwiki;
    final Object services;
    final Object xcontext;
    String maybeRDRInfo;
    final HashMap&lt;String, Long&gt; millisecondsByPeriod;

    Ctx(Object xwiki, Object services, Object xcontext, HashMap millisecondsByPeriod) {
        this.xwiki = xwiki;
        this.services = services;
        this.xcontext = xcontext;
        this.millisecondsByPeriod = millisecondsByPeriod;
    }
}

private Ctx mkCtx(Object xwiki, Object services, Object xcontext)
{
    return new Ctx(xwiki, services, xcontext,
        new HashMap&lt;String, Long&gt;() {{
            put(&quot;minutely&quot;, Long.valueOf(1000L * 60));
            put(&quot;hourly&quot;,   Long.valueOf(1000L * 60 * 60));
            put(&quot;daily&quot;,    Long.valueOf(1000L * 60 * 60 * 24));
            put(&quot;weekly&quot;,   Long.valueOf(1000L * 60 * 60 * 24 * 7));
            put(&quot;monthly&quot;,  Long.valueOf(1000L * 60 * 60 * 24 * 30));
        }});
}

private Object getValue(Object obj, String name) {
    def prop = obj.getProperty(name);
    if (!prop) { return null; }
    return prop.getValue();
}

private String getRDRInfo(Ctx ctx) {
    if (ctx.maybeRDRInfo == null) {
        def confDoc = ctx.xwiki.getDocument(&quot;RISCOSSPlatformCode.RISCOSSConfiguration&quot;);
        def conf = confDoc.getObject(&quot;RISCOSSPlatformCode.RISCOSSConfigurationClass&quot;);
        ctx.maybeRDRInfo = conf.getProperty(&quot;rdr&quot;).getValue();
    }
    return ctx.maybeRDRInfo;
}

public class CmdReturn {
    String stdout = &quot;&quot;;
    String stderr = &quot;&quot;;

    static final int retcode_TIMEOUT = (1&lt;&lt;31);
    int retcode;
}


private CmdReturn runCmd(Ctx ctx, String cmd, String stdin)
{
    System.out.println(&quot;debug: &quot; + cmd + &quot; &lt; &quot; + stdin);

    final CmdReturn out = new CmdReturn();
    final AtomicInteger ai = new AtomicInteger(4);
    final Process[] process = new Process[1];

    new Thread(new Runnable() {public void run() {
        
        process[0] = Runtime.getRuntime().exec(cmd);
        new Thread(new Runnable() {public void run() {
            out.stdout = IOUtils.toString(process[0].getInputStream(), &quot;UTF-8&quot;);
            ai.decrementAndGet();
        } } ).start();
        new Thread(new Runnable() {public void run() {
            out.stderr = IOUtils.toString(process[0].getErrorStream(), &quot;UTF-8&quot;);
            ai.decrementAndGet();
        } } ).start();
        new Thread(new Runnable() {public void run() {
            OutputStream stdinStream = process[0].getOutputStream();
            IOUtils.write(stdin, stdinStream, &quot;UTF-8&quot;);
            stdinStream.close();
            ai.decrementAndGet();
        } } ).start();

        process[0].waitFor();
        out.retcode = process[0].exitValue();
        ai.decrementAndGet();
    }}).start();

    int waitMilliseconds = 0;
    while (ai.get() != 0) {
        Thread.sleep(10);
        waitMilliseconds += 10;
        if (waitMilliseconds &gt; Ctx.COLLECTOR_TIMEOUT_MILLISECONDS) {
            if (process[0] != null) {
                process[0].destroy();
            }
            System.out.println(&quot;warning: TIMEOUT &quot; + cmd + &quot; &lt; &quot; + stdin);
            out.retcode = CmdReturn.retcode_TIMEOUT;
            return out;
        }
    }
    return out;
}

private int uploadToRDR(String output, String rdrPath) throws Exception
{
    HttpClient client = HttpClientBuilder.create().build();
    HttpPost request = new HttpPost(rdrPath);
    request.setEntity(new StringEntity(output));
    HttpResponse response = client.execute(request);
    int responseCode = response.getStatusLine().getStatusCode();
    System.out.println(&quot;Response Code : &quot; + responseCode);
    BufferedReader rd = new BufferedReader(
      new InputStreamReader(response.getEntity().getContent()));
    StringBuffer result = new StringBuffer();
    String line = &quot;&quot;;
    while ((line = rd.readLine()) != null) {
        System.err.println(line);
    }
    if (responseCode &lt; 200 || responseCode &gt; 299) {
        return responseCode;
    }
    return 0;
}

private void runJob(Ctx ctx, Object entityDoc, Object collectorConf, Object scheduleConf) {
    def collectorDoc = ctx.xwiki.getDocument(getValue(scheduleConf, &quot;collectorName&quot;));
    def collectorObj = collectorDoc.getObject(&quot;RISCOSSPlatformDataCollectorCode.DataCollectorClass&quot;);
    def entity = entityDoc.getObject(&quot;RISCOSSPlatformLayerManagerCode.EntityClass&quot;);
    String command = getValue(collectorObj, &quot;command&quot;);
    String rdrPath = getRDRInfo(ctx);
    def out = new JSONObject();
    out.put(&quot;riscoss_targetName&quot;, getValue(entity, &quot;rdids&quot;));
    if (collectorConf != null) {
        for (String propName : collectorConf.getxWikiClass().getEnabledPropertyNames()) {
            out.put(propName, getValue(collectorConf, propName));
        }
    }
    CmdReturn res = runCmd(ctx, command, out.toString());
    System.out.println(&quot;debug: stdout: &quot; + res.stdout);
    System.out.println(&quot;debug: stderr: &quot; + res.stderr);
    System.out.println(&quot;debug: retcode: &quot; + res.retcode);
    if (res.retcode != 0) { return; }
    String stdout = res.stdout;
    if (stdout.indexOf(&quot;-----BEGIN RISK DATA-----&quot;) != -1) {
        stdout = stdout.substring(stdout.indexOf(&quot;-----BEGIN RISK DATA-----&quot;) +
            &quot;-----BEGIN RISK DATA-----&quot;.length());
        stdout = stdout.substring(0, stdout.indexOf(&quot;-----END RISK DATA-----&quot;));
    }
    if (uploadToRDR(stdout, rdrPath) == 0) {
        rescheduleJob(ctx, entityDoc, scheduleConf);
    }
}

private void rescheduleJob(Ctx ctx, Object doc, Object scheduleConf) {
    scheduleConf.set(&quot;timeLastRun&quot;, System.currentTimeMillis());
    doc.saveWithProgrammingRights(&quot;Ran DataCollector&quot;, true);
}

private void runSchedule(Ctx ctx, Object doc, Object scheduleConf) {
    Long timeLastRun = getValue(scheduleConf, &quot;timeLastRun&quot;);
    if (timeLastRun == null) { timeLastRun = 0; }
    String name = getValue(scheduleConf, &quot;collectorName&quot;);
    String fullName = doc.getFullName() + &quot;/&quot; + name;
    Long milliseconds = ctx.millisecondsByPeriod.get(getValue(scheduleConf, &quot;periodicity&quot;));
    if (milliseconds == null) {
        System.out.println(&quot;warning: [&quot; + fullName + &quot;] invalid periodicity [&quot; +
            getValue(scheduleConf, &quot;periodicity&quot;) + &quot;]&quot;);
        return;
    }
    if (System.currentTimeMillis() - timeLastRun &gt; milliseconds) {
        Object collectorConf = doc.getObject(name);
        if (scheduleConf == null) {
            System.out.println(&quot;warning: [&quot; + fullName + &quot;] no object&quot;);
            return;
        }
        try {
            runJob(ctx, doc, collectorConf, scheduleConf);
        } catch (Exception e) {
            System.out.println(&quot;warning: error running [&quot; + fullName + &quot;]&quot;);
            e.printStackTrace();
        }
    } else {
        System.out.println(&quot;debug: [&quot; + fullName + &quot;] skipping because it is not time yet.&quot;);
    }
}

private void runEntity(Ctx ctx, String docName) {

    def doc = ctx.xwiki.getDocument(docName);
    def scheduleConfs = doc.getObjects(&quot;RISCOSSPlatformDataCollectorCode.DataCollectorScheduler&quot;);
    for (int i = 0; i &lt; scheduleConfs.size(); i++) {
        runSchedule(ctx, doc, scheduleConfs.get(i));
    }
}

public void main(Object xcontext, Object services, Object xwiki) {
    Ctx ctx = mkCtx(xwiki, services, xcontext);
    def docNames = ctx.services.query.xwql(
            &quot;from doc.object(&#39;RISCOSSPlatformDataCollectorCode.DataCollectorScheduler&#39;) as sched&quot;
        ).execute();
    def dox = new ArrayList();
    for (int i = 0; i &lt; docNames.size(); i++) {
        runEntity(ctx, docNames.get(i));
    }
}
</content>
</xwikidoc>
